/*
Давайте рассмотрим, как используются обе области памяти (куча и стек), на примере простой программы:
 */
public class MemoryUsageExample {
    private static class Person {
        private final String name;
        private int age;

        private Person(String name) {
            this.name = name; // 6
        }

        public void setAge(int age) {
            this.age = age; // 7
        }
    }


    // 1
    public static void main(String[] args) { // 2
        String name = "Eugene"; // 3
        int age = 26; // 4

        Person person = new Person(name); // 5
        person.setAge(age); // 7
    } // 8
}

/*
1.  При запуске программы JVM выделяет память под кучу и стеки, происходит загрузка в кучу системных классов. Далее создается главный поток исполнения и его стек.
2.  Главный поток начинает выполнение метода main(), создается первый стек-фрейм Frame#1.
3.  В куче создается строковый объект "Eugene", в Frame#1 записывается ссылка на него.
4.  В Frame#1 записывается значение переменной age.
5.  В Frame#1 сперва загружается класс Person, далее в куче происходит аллокация памяти под соответствующий объект Person,
в   Frame#1 записывается ссылка на объект. Стоит отметить, что оба эти действия происходят одновременно и неразрывно (атомарно).
    Перед исполнением конструктора на вершине стека создаётся новый фрейм Frame#2. Т.к в Java ссылки и примитивы передаются по значению,
     в Frame#2 записываются копии ссылок на объект Person и на строку  "Eugene". Исполнение переходит в конструктор.

6.   В конструкторе происходит копирование ссылки на строку "Eugene" в соответствующее поле. Исполнение конструктора заканчивается, память под Frame#2 становится свободной.
7.  Исполнение возвращается в метод main(). Аналогично вызову конструктора происходит вызов метода setAge, создаётся и уничтожается ещё один стек-фрейм.
8.  Метод main() завершает исполнение, освобождается память, выделенная под Frame#1, главный поток завершает исполнение. Программа заканчивается, следовательно,
    JVM освобождает всю память и завершает работу.
 */